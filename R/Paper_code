#####function to identify transiently carried cargo####
####uses a weighted-t-test to calculate the t-statistic 
####then the bayes factor is calulated from the t-statistic
scorer<-function(df1,group,comps,cols,ncores=1){
  require(BayesFactor)
  require(foreach)
  require(doParallel)
  require(weights)
  registerDoParallel(makeCluster(ncores))
  ids<-unique(as.character(df1$ensembl_ID))
  if(length(which(is.na(ids)))>=1) {ids<-ids[-(which(is.na(ids)))] }
  adj.bfs<-foreach(b=1:length(comps), .combine='cbind') %do% {
    tstats<-foreach(i=1:length(ids),.combine="c") %dopar% {
      mat2<-df1[which(as.character(df1$ensembl_ID)==ids[i]),]
      if(dim(mat2)[1]>1){
        wgt<-ecdf(0:max(mat2$Peak.Score))
        wgt<-sapply(mat2$Peak.Score,wgt)+1
      } else {wgt<-2}
      mat1<-mat2[,cols]
      mat1<-mat1[,c(grep(as.character(comps[[b]][1]),colnames(mat1)),
                    grep(as.character(comps[[b]][2]),colnames(mat1)))]
      sub.group<-factor(group[c(grep(as.character(comps[[b]][1]),colnames(mat1)),
                                grep(as.character(comps[[b]][2]),colnames(mat1)))])
      mat3<-mat1[,sub.group==levels(sub.group)[1]]
      mat4<-mat1[,sub.group==levels(sub.group)[2]]
      mat3<-cbind(unlist(mat3),unlist(mat4),rep(wgt,length(wgt)))
      tstat<-weights:::wtd.t.test(mat3[,1],mat3[,2],mat3[,3])$coefficients[1]
    }
    tstats<-replace(tstats,which(is.nan(tstats)),0)
    if(length(which(is.infinite(tstats)))>=1) {
      tstats<-replace(tstats,which(is.infinite(tstats)),max(tstats[-(which(is.infinite(tstats)))]))
    }
    n1<-length(grep(as.character(comps[[b]][1]),colnames(df1[,cols])))
    n2<-length(grep(as.character(comps[[b]][2]),colnames(df1[,cols])))
    
    bfs<-sapply(tstats,function(x) BayesFactor:::ttest.tstat(x,n1,n2)$bf)
  }
  rownames(adj.bfs)<-ids
  cnames<-foreach(i=1:length(comps),.combine='c') %do%{paste(comps[[i]][1],comps[[i]][2],sep="_vs_")}
  cnames<-c(cnames,"Summed.BF")
  TC.BF<-apply(adj.bfs,1,sum)
  fin.scores<-data.frame(adj.bfs,TC.BF)
  colnames(fin.scores)<-cnames
  return(fin.scores)
}

#' internal function used by function 'namer'
#' @param x 
paster<-function(x) {
  paste(x,collapse=" ")
}

#' Beautify the names of the GO categories for plotting
#' @param df A data.frame generated by hypeR function from the 'hypeR' package
namer<-function(df){
  x<-unlist(lapply(strsplit(df$label,"GO_"),paster))
  x<-unlist(lapply(strsplit(x,"_"), paster))
  df$category<-x
  return(df)
}

#' Plotting enrichment bar charts using ggplot2 to make a plot similar to hyp_plot from the hypeR package to allow greater flexibility in display
#' @param df A data.frame generated by 'hypeR' or 'namer'
#' @param top The number of top categories to include, default=10
#' @param main Title of graph
#' @param fills List of colors of used for "Contribution" and "category" size
hyp_plot2<-function(dfa,top=10,main="Top Categories",fills=c("deepskyblue","red4")){
  dfa<-dfa$data
  dfa<-namer(dfa)
  dfa <- head(dfa, top)
  df.1 <- dfa[, c(9, 3:6)]
  df.2 <- df.1
  df.2$log.fdr <- -log10(df.1$fdr)
  df.2$Contribution <- df.1$overlap/df.1$geneset * df.2$log.fdr
  df.2$x1 <- df.2$log.fdr - df.2$Contribution
  df.3<-df.2[,c(1,7)]
  df.3$Membership<-rep("Cargo",top)
  df.4<-df.2[,c(1,8)]
  colnames(df.4)<-c("category","Contribution")
  df.4$Membership<-rep("Not Cargo",top)
  df.2<-rbind(df.4,df.3)
  df.2$category<-str_wrap(df.2$category,width=30)
  
  p1<- ggplot(df.2,aes(y = Contribution, x = category)) + theme_bw() + theme(axis.text=element_text(size=10))
  p1<- p1 + geom_col(aes(fill=Membership))+coord_flip()
  p1<- p1 + theme(legend.position="bottom", legend.direction="horizontal") +scale_fill_discrete(name="Percent of Category")
  p1<- p1 + scale_fill_manual(values=fills)
  p1<- p1+ labs(x=element_blank(), y="log(FDR)") + theme(legend.text=element_text(size=10))
  p1<- p1 + labs(title=main) + theme(plot.title=element_text(hjust=0)) +xlab("log(FDR)")
  p1
}

#' Plot distribution of peaks by feature pie chart and table
#'
#' @param df A data.frame generated by the hanno function
#' @param fills Colors for pie chart, must be a vector of length 5. Current colors are colorblind safe.
#' @param export If you want to export the graphs fill in a file name here, eg "Distribution_graphs.pdf", when exporting two graphs are generated one is the pie chart/table and the other is a distribution of peaks per gene
distribution_with_plots<-function(dfa,fills=c("yellow","darkred","cadetblue1","purple3","green4")) {
  require(dplyr)
  require(tibble)
  require(foreach)
  anno<-as.data.frame(table(dfa$genome_location))
  colnames(anno)<-c("Feature","Number")
  anno.tb<-tibble(anno)
  anno.tb<-tibble(x=1,y=-0.5,tb=list(anno))
  anno.pie<-ggplot(anno,aes(x=2,y=Number,fill=Feature)) + geom_col(width=1)
  anno.pie<- anno.pie+coord_polar("y",start=90,clip="off")+scale_fill_manual(values=fills) + theme_void() + xlim(0.5, 2.5)
  anno.pie<-anno.pie + geom_table(data=anno.tb,aes(x,y,label=tb), vjust=0.35,hjust=.90,colour="dark blue", size=3)
  
  x<-unique(as.character(dfa$ensembl_ID))
  pks_per_gene<-foreach(i=1:length(x),.combine='c') %do% {
      length(which(as.character(dfa$ensembl_ID)==x[i]))
  }
  names(pks_per_gene)<-x
  x<-foreach(i=1:max(pks_per_gene),.combine='c') %dopar% { length(which(pks_per_gene==i))}
  x<-data.frame(1:max(pks_per_gene),x)
  colnames(x)<-c("Peaks_gene","Number_genes")
  p1<-ggplot(x,(aes(x=Peaks_gene,y=Number_genes))) + geom_bar(sta='identity')
    p1<-p1 + labs(y="Number of Genes",x="Peaks per Gene") + ggtitle("Distribution of Peaks per Gene")
    p1<-p1 + theme(text = element_text(size=12))
    
fin<-list(dfa,anno.pie,p1)
names(fin)<-c("Adj.anno.df","Pie_chart","Peakpergene_plot")
return(fin)
}

#function for reading in bam counts
Read.bam.in<-function(x,RNA,singleEnd=TRUE){
	blue<-foreach(i=1:length(x),.combine='cbind') %do% {
	print(paste("Processing ",x[i]))
	bf<-BamFile(x[i],yieldSize=5000000)
	open(bf)
	cvg<-NULL
	repeat{
		yld <- readGAlignments(bf)
		if (length(yld) == 0L) break
		chunk.cvg<-assay(summarizeOverlaps(RNA,yld,mode="IntersectionNotEmpty",
		singleEnd=singleEnd,fragments=TRUE, ignore.strand=F))
		if (is.null(cvg)) {cvg<-chunk.cvg} else {cvg<-cvg+chunk.cvg}}
	close(bf)
	cvg
	}
	colnames(blue)<-x
	RNA.cts<-blue
	return(RNA.cts)
}

# function to normalize counts by sampling 
# to 10 million reads similar to Homer program

resample<-function(mat){
  require(foreach)
  z1<-apply(mat,2,sum)
  z1<-mat/z1
  fin<-foreach(i=1:dim(z1)[2],.combine='cbind') %do% {
    samp<-foreach(b=1:100,.combine='cbind') %do% {
      z2<-sample(rownames(z1),10000000,replace=T,prob=z1[,i])
      z2<-table(z2)
      y1<-setdiff(rownames(z1),names(z2))
      y2<-rep(0,length(y1))
      names(y2)<-y1
      z2<-c(z2,y2)
      z2<-z2[sort(rownames(z1))]
    }
    trunc(apply(samp,1,mean))
  }
  rownames(fin)<-sort(rownames(z1))
  return(fin)
}

####function to generate an annotation file from genecode data broken into introns, intergenic, exon, and UTR regions
make_anno<-function(filename) {
  require(GenomicFeatures)
  M21 <- makeTxDbFromGFF(filename, format="gtf")
  x1<-exonsBy(M21,"tx")
  x2<-intronsByTranscript(M21)
  x3<-fiveUTRsByTranscript(M21)
  x4<-threeUTRsByTranscript(M21)
  x5<-gaps(unlist(genes(M21, single.strand.genes.only=FALSE)))
  granno<-list(x1,x2,x3,x4,x5)
  names(granno)<-c("Exon","Intron","5UTR","3UTR","Intergenic")
  return(granno)
 }
  
####function for annotating peaks with strandness taken into account
###@ param gr1= Granges object generated from homer peak file for positive strand 
###@ param gr2= Granges object generated from homer peak file for negative strand 
###@ granno= annotation file generated by make_anno function
###@ numb= min counts for a sample
###@ group.num= minimum number of sample with the min count set by param numb
hanno<-function(gr1,gr2,granno,cts.col=NULL,numb=5,group.num=3){
  require(foreach)
  require(dplyr)
  fin1<-foreach(i=1:4,.combine='rbind') %do%{
    y<-granno[[i]]
    z<-suppressWarnings(findOverlaps(gr1,y))
    z1<-as.data.frame(gr1[z@from],row.names=as.character(1:length(z)))
    y1<-names(y[z@to])
    y1<-names(y[y1])
    ensembl_ID<-TID2ensID[y1]
    gene_symbol<-ensID2SYM[TID2ensID[y1]]
    genome_location<-rep(names(granno)[i],dim(z1)[1])
    data.frame(z1,genome_location,gene_symbol,ensembl_ID)
  }
  fin1<-fin1[order(fin1$genome_location,decreasing=F),]
  fin1<-fin1[-(which(duplicated(fin1[,1:6]))),]
  fin2<-foreach(i=1:4,.combine='rbind') %do%{
    y<-granno[[i]]
    z<-suppressWarnings(findOverlaps(gr2,y))
    z1<-as.data.frame(gr2[z@from],row.names=as.character(1:length(z)))
    y1<-names(y[z@to])
    y1<-names(y[y1])
    ensembl_ID<-TID2ensID[y1]
    gene_symbol<-ensID2SYM[TID2ensID[y1]]
    genome_location<-rep(names(granno)[i],dim(z1)[1])
    data.frame(z1,genome_location,gene_symbol,ensembl_ID)
  }
  fin2<-fin2[order(fin2$genome_location,decreasing=F),]
  fin2<-fin2[-(which(duplicated(fin2[,1:6]))),]
  
  y<-granno[[5]]
  z<-suppressWarnings(findOverlaps(gr1,y))
  z1<-as.data.frame(gr1[z@from],row.names=as.character(1:length(z)))
  z<-suppressWarnings(findOverlaps(gr1,y))
  z2<-as.data.frame(gr1[z@from],row.names=as.character(1:length(z)))
  z<-inner_join(z1,z2,by="peaks")
  z1<-z[,1:(dim(fin1)[2]-3)]
  z2<-z[,(dim(fin1)[2]-2):dim(z)[2]]
  z3<-z1[,8:dim(z1)[2]]+z2[,7:dim(z2)[2]]
  z<-cbind(z1[,1:7],z3)
  z$genome_location<-"Intergenic"
  z$gene_symbol<-NA
  z$ensembl_ID<-NA
  colnames(z)<-colnames(fin1)
  z<-z[-(which(duplicated(z[,1:4]))),]
  fin<-rbind(fin1,fin2,z)
  fin<-fin[order(fin$genome_location,decreasing=F),]
  x<-data.frame(names(which(table(fin$peaks)>2)))
  colnames(x)<-"peaks"
  x1<-semi_join(fin,x,by="peaks")
  x1<-x1[-(which(x1$genome_location=="Intergenic")),]
  x2<-anti_join(fin,x,by="peaks")
  fin<-rbind(x1,x2)
  colnames(fin)<-c("chr",colnames(fin)[2:dim(fin)[2]])
  if(is.null(cts.col)){
    return(fin)} else {
      y<-apply(fin[,cts.col],1,function(x) length(which(x>numb)))
      fin<-fin[-(which(y<=group.num)),]
      return(fin)
    }
}
#########ggplot color replicator
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}

###make treemap from hypeR enrichment file
treemap_hyperGO<-function(enr_df,goterms,res.h=0.8,orgdb="org.Mm.eg.db") {
  require(treemapify)
  require(rrvgo)
  require(LSAfun)
  sizes<-(-(log(enr_df$data$fdr)))
  y<-unlist(substring(enr_df$data$label,4))
  y<-breakdown(y)
  y<-goterms[y]
  z<-which(is.na(y))
  y<-y[-z]
  names(sizes)<-y
  sizes<-sizes[-(which(is.na(names(sizes))))]
  sm<-calculateSimMatrix(y,orgdb=orgdb,ont="BP",method="Rel")
  x<-intersect(y,rownames(sm))
  sizes<-sizes[x]
  o <- rev(order(sizes, na.last = FALSE))
  sm <- sm[o, o]
  cluster <- cutree(hclust(as.dist(1 - sm)), h = res.h)
  clusterRep <- tapply(rownames(sm), cluster, function(x) x[which.max(sizes[x])])
  red<-data.frame(go = rownames(sm), 
                  cluster = cluster, 
                  parent = clusterRep[cluster],
                  parentSimScore = unlist(Map(seq_len(nrow(sm)), 
                                              clusterRep[cluster], f = function(i, j) sm[i,j])), 
                  size = sizes[match(rownames(sm), names(sizes))],
                  term = rrvgo:::getGoTerm(rownames(sm)), 
                  parentTerm = rrvgo:::getGoTerm(clusterRep[cluster]))
  
  ncolors<-gg_color_hue(length(unique(red$parentTerm)))
  mcolors<-red$parentTerm
  for(i in 1:length(ncolors)){
    mcolors[which(mcolors==unique(red$parentTerm)[i])]<-ncolors[i]
  }
  red$mcolors<-mcolors
  
  p<-ggplot(red, aes(area=sizes,subgroup=parentTerm,fill=mcolors))
  p<-p + geom_treemap()
  p<-p + geom_treemap_subgroup_border()
  p<-p + geom_treemap_subgroup_text(place='center',grow=F,alpha=1,min.size=6,reflow=T)
  p<-p + theme(legend.position = "none")
  p
}

#######load data and make objects for analysis
library(hypeR)
library(dplyr)
library(ggplot2)
library(ggthemes)
library(ggpmisc)
library(stringr)
library(biomaRt)
library(GenomicFeatures)
library(rtracklayer)
library(Rsamtools)
library(GenomicRanges)
library(RColorBrewer)
library(GenomicAlignments)
library(foreach)
library(akmedoids)
library(GO.db)


granno<-make_anno("gencode.vM21.annotation.gtf")

mus<-useMart("ensembl", dataset = "mmusculus_gene_ensembl")
z<- getBM(attributes=c("entrezgene_id","mgi_symbol","ensembl_gene_id","ensembl_transcript_id","ensembl_exon_id"),
          uniqueRows = F, mart = mus)
Ex2ensID<-z[,3]
names(Ex2ensID)<-z[,5]
ensID2SYM<-z[,2]
names(ensID2SYM)<-z[,3]
ensID2ent<-z[,1]
names(ensID2ent)<-z[,3]
unique(ensID2SYM)[1:5]
ensID2SYM<-ensID2SYM[-(which(duplicated(names(ensID2SYM))))]
ensID2ent<-ensID2ent[-(which(duplicated(names(ensID2ent))))]

x <- Term(GOTERM)
goterms<-names(x)
names(goterms)<-x

###read in peaks file from homer to make a granges peak object for pos and neg strands
peaks<-data.frame(read.delim("Peak.counts.txt"))
peaks<-peaks[,1:6]
colnames(peaks)<-c("peak",colnames(peaks[,2:6]))
hneg<-peaks
hneg$Strand<-"-"

hpos.gr<-makeGRangesFromDataFrame(peaks,keep.extra.columns = T) 
hneg.gr<-makeGRangesFromDataFrame(hneg,keep.extra.columns = T) 

group<-c(11,11,11,13,13,13,15,15,15,17,17,17)
comps<-list(c(11,13),c(13,15),c(15,17),c(11,17))
cols<-8:19

REACTOME <- msigdb_gsets(species="Mus musculus", category="C2", subcategory="CP:REACTOME")
GOBP <- msigdb_gsets(species="Mus musculus", category="C5", subcategory="BP")
GOMF <- msigdb_gsets(species="Mus musculus", category="C5", subcategory="MF")

xa<-foreach(i=1:length(granno$Exon),.combine='rbind') %do% {
  x1a<-strsplit(granno$Exon[i]@unlistData$exon_name,"\\.")[[1]][1]
  x1b<-rep(names(granno$Exon[i]),length(x1a))
  cbind(x1a,x1b)
}
TID2ensID<-Ex2ensID[xa[,1]]
names(TID2ensID)<-xa[,2]

#######read in counts from bam files using the peak granges object
###### then normalize counts by resampling to 10 million counts
##### and make an annotated peak data frame

x<-dir()
x<-x[grep("SIP",x)]

pos.cts<-Read.bam.in(x,hpos.gr)
rownames(pos.cts)<-hpos.gr@elementMetadata$peaks
neg.cts<-Read.bam.in(x,hneg.gr)
rownames(neg.cts)<-hneg.gr@elementMetadata$peaks

z1<-resample(pos.cts)
colnames(z1)<-c("e11_1","e11_2","e11_3","e13_1","e13_2","e13_3",
                "e15_1","e15_2","e15_3","e17_1","e17_2","e17_3")
y1<-resample(neg.cts)
colnames(y1)<-c("e11_1","e11_2","e11_3","e13_1","e13_2","e13_3",
               "e15_1","e15_2","e15_3","e17_1","e17_2","e17_3")
               
hpos<-peaks[order(peaks$peaks),]
hneg<-hneg[order(hneg$peaks),]
hpos<-cbind(hpos[,1:6],z1)
hneg<-cbind(hneg[,1:6],y1)
hpos.gr<-makeGRangesFromDataFrame(hpos,keep.extra.columns = T) 
hneg.gr<-makeGRangesFromDataFrame(hneg,keep.extra.columns = T) 

test<-hanno(hpos.gr,hneg.gr,granno,cols)

#####Analyze peak data
#######describe distribution of peaks by feature
dfa<-distribution_with_plots(test)
pdf(file="New_Stau2_peak_plots.pdf",onefile=T,paper="letter",width=7.5,height=10)
dfa[[2]]
dfa[[3]]
dev.off()



###set up dataframe for Bayes factor analysis to look for genes 
###differrntally binding across time course
###trimmed peak score and calculated elbow point
###used a peak score greater than the elbow point as cut off based on endothelial data set
dft<-test[-(which(test$genome_location=="Intergenic")),]

###trim ends of peak scores and find elbow point or knee to use as cutoff
trimmed<-peaks$Peak.Score
trimmed<-sort(trimmed,decreasing=F)
trimmed<-trimmed[trunc(length(trimmed)*0.2):trunc(length(trimmed)*.8)]
ep<-elbowPoint(1:length(trimmed),trimmed)

dft<-dft[dft$Peak.Score>ep$y,]


score.clean<-scorer(dft,group,comps,cols,ncores=3)
x<-data.frame(score.clean,ensID2SYM[rownames(score.clean)])
colnames(x)<-c(colnames(score.clean),"Gene_Symbols")
write.csv(x,"Scores.Table.csv")


####divide genes into three groups, dynamic, stable, and in-between
dyn.ch<-score.clean[which(exp(score.clean$Summed.BF)>=100),]
t1<-ensID2SYM[rownames(dyn.ch)]
stab<-score.clean[which(exp(score.clean$Summed.BF)<3.2),]
s1<-ensID2SYM[rownames(stab)]
m1<-setdiff(ensID2SYM[rownames(score.clean)],t1)
m1<-setdiff(x,s1)

t1.bp<- hypeR(t1, GOBP, background=55487, fdr=0.01)
t1.path<-hypeR(t1, REACTOME, background=55487, fdr=0.01)
t1.mf<- hypeR(t1, GOMF, background=55487, fdr=0.01)


m1.path<-hypeR(m1, REACTOME, background=55487, fdr=0.01)
m1.bp<- hypeR(m1, GOBP, background=55487, fdr=0.01)
m1.mf<- hypeR(t1, GOMF, background=55487, fdr=0.01)


stab.bp<- hypeR(s1, GOBP, background=55487, fdr=0.01)
stab.path<-hypeR(s1, REACTOME, background=55487, fdr=0.01)
stab.mf<- hypeR(s1, GOMF, background=55487, fdr=0.01)


write.csv(t1.path,"Decisively_Dynamic_pathways.csv")
write.csv(t1.bp,"Decisively_Dynamic_GOBP.csv")
write.csv(t1.mf,"Decisively_Dynamic_GOMF.csv")

write.csv(m1.path,"Potenitally_Dynamic_pathways.csv")
write.csv(m1.bp,"Potenitally_Dynamic_GOBP.csv")
write.csv(m1.mf,"Potenitally_Dynamic_GOMF.csv")

write.csv(stab.path,"Stable_pathways.csv")
write.csv(stab.bp,"Stable_GOBP.csv")
write.csv(stab.mf,"Stable_GOMF.csv")



pdf(file="Stau2_plots.pdf",onefile=T,paper="letter",width=7.5,height=10)
hyp_plot2(t1.path,main="Top Signaling Pathways for Decisively Dynamic Genes")
hyp_plot2(t1.bp,main="Top GO:BP categories for Decisively Dynamic Genes")
hyp_plot2(t1.mf,main="Top GO:MF categories for Decisively Dynamic Genes")
hyp_plot2(m1.path,main="Top Signaling Pathways for Potenitally Dynamic Genes")
hyp_plot2(m1.bp,main="Top GO:BP categories for Potenitally Dynamic Genes")
hyp_plot2(m1.mf,main="Top GO:MF categories for Potenitally Dynamic Genes")
hyp_plot2(stab.path,main="Top Signaling Pathways for Stable Genes")
hyp_plot2(stab.bp, main="Top GO:BP categories for Stable Genes")
hyp_plot2(stab.mf, main="Top GO:MF categories for Stable Genes")
dev.off()

y<-intersect(GOMF$genesets$"GO_TRANSCRIPTION_FACTOR_BINDING",t1)
x<-intersect(GOMF$genesets$"GO_TRANSCRIPTION_FACTOR_BINDING",m1)
z<-intersect(GOMF$genesets$"GO_TRANSCRIPTION_FACTOR_BINDING",s1)
y<-cbind(y,rep("Decisively_Dynamic"))
x<-cbind(x,rep("Potentially_Dynamic"))
z<-cbind(z,rep("Stable"))
TF.table<-rbind(x,y,z)
colnames(TF.table)<-c("Gene","Stability")
write.csv(TF.table,"TF.table.csv")


write.csv(test,"MasterPeaks.cts.csv")


sessionInfo()
#R version 3.6.0 (2019-04-26)
#latform: x86_64-w64-mingw32/x64 (64-bit)
#Running under: Windows 10 x64 (build 17763)

#Matrix products: default

#locale:
#  [1] LC_COLLATE=English_United States.1252  LC_CTYPE=English_United States.1252    LC_MONETARY=English_United States.1252
#[4] LC_NUMERIC=C                           LC_TIME=English_United States.1252    

#attached base packages:
# [1] stats4    parallel  stats     graphics  grDevices utils     datasets  methods   base     

#other attached packages:
#  [1] weights_1.0            mice_3.6.0             gdata_2.18.0           Hmisc_4.2-0            Formula_1.2-3         
#[6] survival_2.44-1.1      lattice_0.20-38        reshape2_1.4.3         ggpmisc_0.3.1          stringr_1.4.0         
#[11] ggthemes_4.2.0         ggplot2_3.1.1          dplyr_0.8.1            genefilter_1.66.0      org.Mm.eg.db_3.8.2    
#[16] AnnotationDbi_1.46.0   IRanges_2.18.1         S4Vectors_0.22.0       Biobase_2.44.0         BiocGenerics_0.30.0   
#[21] hypeR_1.00.0           doParallel_1.0.14      iterators_1.0.10       foreach_1.4.4          BayesFactor_0.9.12-4.2
#[26] Matrix_1.2-17          coda_0.19-2           

#loaded via a namespace (and not attached):
#  [1] nlme_3.1-140        bitops_1.0-6        bit64_0.9-7         RColorBrewer_1.1-2  httr_1.4.0          tools_3.6.0        
# [7] backports_1.1.4     R6_2.4.0            DT_0.6              rpart_4.1-15        DBI_1.0.0           lazyeval_0.2.2     
#[13] colorspace_1.4-1    jomo_2.6-9          nnet_7.3-12         withr_2.1.2         tidyselect_0.2.5    gridExtra_2.3      
#[19] bit_1.1-14          compiler_3.6.0      htmlTable_1.13.1    plotly_4.9.0        labeling_0.3        scales_1.0.0       
#[25] checkmate_1.9.3     mvtnorm_1.0-10      pbapply_1.4-0       digest_0.6.19       minqa_1.2.4         foreign_0.8-71     
#[31] base64enc_0.1-3     pkgconfig_2.0.2     htmltools_0.3.6     lme4_1.1-21         htmlwidgets_1.3     rlang_0.3.4        
#[37] rstudioapi_0.10     RSQLite_2.1.1       generics_0.0.2      jsonlite_1.6        gtools_3.8.1        acepack_1.4.1      
#[43] zip_2.0.3           RCurl_1.95-4.12     magrittr_1.5        Rcpp_1.0.2          munsell_0.5.0       stringi_1.4.3      
#[49] MASS_7.3-51.4       plyr_1.8.4          grid_3.6.0          blob_1.1.1          mitml_0.3-7         crayon_1.3.4       
#[55] splines_3.6.0       msigdbr_6.2.1       annotate_1.62.0     knitr_1.23          pillar_1.4.1        boot_1.3-22        
#[61] codetools_0.2-16    pan_1.6             XML_3.98-1.19       glue_1.3.1          latticeExtra_0.6-28 data.table_1.12.2  
#[67] nloptr_1.2.1        MatrixModels_0.4-1  gtable_0.3.0        purrr_0.3.2         tidyr_0.8.3         assertthat_0.2.1   
#[73] xfun_0.7            openxlsx_4.1.0.1    broom_0.5.2         xtable_1.8-4        viridisLite_0.3.0   tibble_2.1.2       
#[79] memoise_1.1.0       cluster_2.0.9 
  

